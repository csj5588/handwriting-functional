/**
 * 声明式
 * 
 * 我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。
 * 我敢保证，这种做法与那种需要时刻关心所有细节的命令式编程相比，会让你轻松许多。

    与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。

    以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。
    至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，
    根本不需要更改查询语句。这是因为，有多种方式解析一个表达式并得到相同的结果。

    对包括我在内的一些人来说，一开始是不太容易理解“声明式”这个概念的；所以让我们写几个例子找找感觉。
 */

// 命令式
var makes = [];
for (i = 0; i < cars.length; i++) {
  makes.push(cars[i].make);
}

// 声明式
var makes = cars.map(function(car) { return car.make })

/**
 * 命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，
 * 解释器才继续执行后面的代码。然后在直接迭代cars列表，手动增加计数器
 * 把各种零零散散的东西都展示出来。。。实在是直白的有些露骨
 * 
 * 使用map的版本是一个表达式，它对执行顺序没有要求。而且，map函数如何进行迭代，
 * 返回的数组如何收集，都有很大的自由度。它指明的是做什么，不是怎么做。因此，它是正了八景的声明式代码。
 * 
 * 除了更加清晰和简洁之外，map函数还可以进行进一步优化，这么依赖我们宝贵的代码就无需改动了。
 * 
 * 至于那些说“虽然如此，但使用命令式循环速度要快很多”的人，
 * 我建议你们先去学学 JIT 优化代码的相关知识。这里有一个非常棒的视频，可能会对你有帮助。
 * https://www.youtube.com/watch?v=65-RbBwZQdU
 */

// 命令式
var authenticate = function(form) {
  var user = toUser(form);
  return logIn(user);
};

// 声明式
var authenticate = compose(logIn, toUser);

/**
 * 虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。
 * 而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser 和 logIn 两个行为的组合。
 * 这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。

   因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。
   它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。
 */

