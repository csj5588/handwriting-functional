/**
 * 自由定理
   类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理（free theorems）。
   下面是两个直接从 Wadler 关于此主题的论文 中随机选择的例子：

   // head :: [a] -> a
   compose(f, head) == compose(head, map(f));

   // filter :: (a -> Bool) -> [a] -> [a]
   compose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));
   不用写一行代码你也能理解这些定理，它们直接来自于类型本身。
   第一个例子中，等式左边说的是，先获取数组的头部（译者注：即第一个元素），然后对它调用函数 f；
   等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。

   你可能会想，这不是常识么。但根据我的调查，计算机是没有常识的。
   实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。
   数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。

   第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，
   然后再通过 map 实际调用 f（别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；
   等式右边是说，先用 map 调用 f，然后再根据 p 过滤元素。这两者也是相等的。

   以上只是两个例子，但它们传达的定理却是普适的，可以应用到所有的多态性类型签名上。
   在 JavaScript 中，你可以借助一些工具来声明重写规则，也可以直接使用 compose 函数来定义重写规则。
   总之，这么做的好处是显而易见且唾手可得的，可能性则是无限的。
 */